{"ast":null,"code":"import * as Caml_int32 from \"./caml_int32.js\";\nimport * as Caml_utils from \"./caml_utils.js\";\nimport * as Caml_primitive from \"./caml_primitive.js\";\nimport * as Caml_builtin_exceptions from \"./caml_builtin_exceptions.js\";\nvar min_int =\n/* record */\n[\n/* hi */\n-2147483648,\n/* lo */\n0];\nvar max_int =\n/* record */\n[\n/* hi */\n2147483647,\n/* lo */\n1];\nvar one =\n/* record */\n[\n/* hi */\n0,\n/* lo */\n1];\nvar zero =\n/* record */\n[\n/* hi */\n0,\n/* lo */\n0];\nvar neg_one =\n/* record */\n[\n/* hi */\n-1,\n/* lo */\n4294967295];\n\nfunction neg_signed(x) {\n  return (x & 2147483648) !== 0;\n}\n\nfunction add(param, param$1) {\n  var other_low_ = param$1[\n  /* lo */\n  1];\n  var this_low_ = param[\n  /* lo */\n  1];\n  var lo = this_low_ + other_low_ & 4294967295;\n  var overflow = neg_signed(this_low_) && (neg_signed(other_low_) || !neg_signed(lo)) || neg_signed(other_low_) && !neg_signed(lo) ? 1 : 0;\n  var hi = param[\n  /* hi */\n  0] + param$1[\n  /* hi */\n  0] + overflow & 4294967295;\n  return (\n    /* record */\n    [\n    /* hi */\n    hi,\n    /* lo */\n    lo >>> 0]\n  );\n}\n\nfunction not(param) {\n  var hi = param[\n  /* hi */\n  0] ^ -1;\n  var lo = param[\n  /* lo */\n  1] ^ -1;\n  return (\n    /* record */\n    [\n    /* hi */\n    hi,\n    /* lo */\n    lo >>> 0]\n  );\n}\n\nfunction eq(x, y) {\n  if (x[\n  /* hi */\n  0] === y[\n  /* hi */\n  0]) {\n    return x[\n    /* lo */\n    1] === y[\n    /* lo */\n    1];\n  } else {\n    return false;\n  }\n}\n\nfunction equal_null(x, y) {\n  if (y !== null) {\n    return eq(x, y);\n  } else {\n    return false;\n  }\n}\n\nfunction equal_undefined(x, y) {\n  if (y !== undefined) {\n    return eq(x, y);\n  } else {\n    return false;\n  }\n}\n\nfunction equal_nullable(x, y) {\n  if (y == null) {\n    return false;\n  } else {\n    return eq(x, y);\n  }\n}\n\nfunction neg(x) {\n  if (eq(x, min_int)) {\n    return min_int;\n  } else {\n    return add(not(x), one);\n  }\n}\n\nfunction sub(x, y) {\n  return add(x, neg(y));\n}\n\nfunction lsl_(x, numBits) {\n  if (numBits === 0) {\n    return x;\n  } else {\n    var lo = x[\n    /* lo */\n    1];\n\n    if (numBits >= 32) {\n      return (\n        /* record */\n        [\n        /* hi */\n        lo << (numBits - 32 | 0),\n        /* lo */\n        0]\n      );\n    } else {\n      var hi = lo >>> (32 - numBits | 0) | x[\n      /* hi */\n      0] << numBits;\n      return (\n        /* record */\n        [\n        /* hi */\n        hi,\n        /* lo */\n        lo << numBits >>> 0]\n      );\n    }\n  }\n}\n\nfunction lsr_(x, numBits) {\n  if (numBits === 0) {\n    return x;\n  } else {\n    var hi = x[\n    /* hi */\n    0];\n    var offset = numBits - 32 | 0;\n\n    if (offset === 0) {\n      return (\n        /* record */\n        [\n        /* hi */\n        0,\n        /* lo */\n        hi >>> 0]\n      );\n    } else if (offset > 0) {\n      var lo = hi >>> offset;\n      return (\n        /* record */\n        [\n        /* hi */\n        0,\n        /* lo */\n        lo >>> 0]\n      );\n    } else {\n      var hi$1 = hi >>> numBits;\n      var lo$1 = hi << (-offset | 0) | x[\n      /* lo */\n      1] >>> numBits;\n      return (\n        /* record */\n        [\n        /* hi */\n        hi$1,\n        /* lo */\n        lo$1 >>> 0]\n      );\n    }\n  }\n}\n\nfunction asr_(x, numBits) {\n  if (numBits === 0) {\n    return x;\n  } else {\n    var hi = x[\n    /* hi */\n    0];\n\n    if (numBits < 32) {\n      var hi$1 = hi >> numBits;\n      var lo = hi << (32 - numBits | 0) | x[\n      /* lo */\n      1] >>> numBits;\n      return (\n        /* record */\n        [\n        /* hi */\n        hi$1,\n        /* lo */\n        lo >>> 0]\n      );\n    } else {\n      var lo$1 = hi >> (numBits - 32 | 0);\n      return (\n        /* record */\n        [\n        /* hi */\n        hi >= 0 ? 0 : -1,\n        /* lo */\n        lo$1 >>> 0]\n      );\n    }\n  }\n}\n\nfunction is_zero(param) {\n  if (param[\n  /* hi */\n  0] !== 0 || param[\n  /* lo */\n  1] !== 0) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction mul(_this, _other) {\n  while (true) {\n    var other = _other;\n    var $$this = _this;\n    var exit = 0;\n    var lo;\n    var this_hi = $$this[\n    /* hi */\n    0];\n    var exit$1 = 0;\n    var exit$2 = 0;\n    var exit$3 = 0;\n\n    if (this_hi !== 0 || $$this[\n    /* lo */\n    1] !== 0) {\n      exit$3 = 4;\n    } else {\n      return zero;\n    }\n\n    if (exit$3 === 4) {\n      if (other[\n      /* hi */\n      0] !== 0 || other[\n      /* lo */\n      1] !== 0) {\n        exit$2 = 3;\n      } else {\n        return zero;\n      }\n    }\n\n    if (exit$2 === 3) {\n      if (this_hi !== -2147483648 || $$this[\n      /* lo */\n      1] !== 0) {\n        exit$1 = 2;\n      } else {\n        lo = other[\n        /* lo */\n        1];\n        exit = 1;\n      }\n    }\n\n    if (exit$1 === 2) {\n      var other_hi = other[\n      /* hi */\n      0];\n      var lo$1 = $$this[\n      /* lo */\n      1];\n      var exit$4 = 0;\n\n      if (other_hi !== -2147483648 || other[\n      /* lo */\n      1] !== 0) {\n        exit$4 = 3;\n      } else {\n        lo = lo$1;\n        exit = 1;\n      }\n\n      if (exit$4 === 3) {\n        var other_lo = other[\n        /* lo */\n        1];\n\n        if (this_hi < 0) {\n          if (other_hi < 0) {\n            _other = neg(other);\n            _this = neg($$this);\n            continue;\n          } else {\n            return neg(mul(neg($$this), other));\n          }\n        } else if (other_hi < 0) {\n          return neg(mul($$this, neg(other)));\n        } else {\n          var a48 = this_hi >>> 16;\n          var a32 = this_hi & 65535;\n          var a16 = lo$1 >>> 16;\n          var a00 = lo$1 & 65535;\n          var b48 = other_hi >>> 16;\n          var b32 = other_hi & 65535;\n          var b16 = other_lo >>> 16;\n          var b00 = other_lo & 65535;\n          var c48 = 0;\n          var c32 = 0;\n          var c16 = 0;\n          var c00 = a00 * b00;\n          c16 = (c00 >>> 16) + a16 * b00;\n          c32 = c16 >>> 16;\n          c16 = (c16 & 65535) + a00 * b16;\n          c32 = c32 + (c16 >>> 16) + a32 * b00;\n          c48 = c32 >>> 16;\n          c32 = (c32 & 65535) + a16 * b16;\n          c48 += c32 >>> 16;\n          c32 = (c32 & 65535) + a00 * b32;\n          c48 += c32 >>> 16;\n          c32 = c32 & 65535;\n          c48 = c48 + (a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48) & 65535;\n          var hi = c32 | c48 << 16;\n          var lo$2 = c00 & 65535 | (c16 & 65535) << 16;\n          return (\n            /* record */\n            [\n            /* hi */\n            hi,\n            /* lo */\n            lo$2 >>> 0]\n          );\n        }\n      }\n    }\n\n    if (exit === 1) {\n      if ((lo & 1) === 0) {\n        return zero;\n      } else {\n        return min_int;\n      }\n    }\n  }\n\n  ;\n}\n\nfunction swap(param) {\n  var hi = Caml_int32.caml_int32_bswap(param[\n  /* lo */\n  1]);\n  var lo = Caml_int32.caml_int32_bswap(param[\n  /* hi */\n  0]);\n  return (\n    /* record */\n    [\n    /* hi */\n    hi,\n    /* lo */\n    lo >>> 0]\n  );\n}\n\nfunction xor(param, param$1) {\n  return (\n    /* record */\n    [\n    /* hi */\n    param[\n    /* hi */\n    0] ^ param$1[\n    /* hi */\n    0],\n    /* lo */\n    (param[\n    /* lo */\n    1] ^ param$1[\n    /* lo */\n    1]) >>> 0]\n  );\n}\n\nfunction or_(param, param$1) {\n  return (\n    /* record */\n    [\n    /* hi */\n    param[\n    /* hi */\n    0] | param$1[\n    /* hi */\n    0],\n    /* lo */\n    (param[\n    /* lo */\n    1] | param$1[\n    /* lo */\n    1]) >>> 0]\n  );\n}\n\nfunction and_(param, param$1) {\n  return (\n    /* record */\n    [\n    /* hi */\n    param[\n    /* hi */\n    0] & param$1[\n    /* hi */\n    0],\n    /* lo */\n    (param[\n    /* lo */\n    1] & param$1[\n    /* lo */\n    1]) >>> 0]\n  );\n}\n\nfunction ge(param, param$1) {\n  var other_hi = param$1[\n  /* hi */\n  0];\n  var hi = param[\n  /* hi */\n  0];\n\n  if (hi > other_hi) {\n    return true;\n  } else if (hi < other_hi) {\n    return false;\n  } else {\n    return param[\n    /* lo */\n    1] >= param$1[\n    /* lo */\n    1];\n  }\n}\n\nfunction neq(x, y) {\n  return !eq(x, y);\n}\n\nfunction lt(x, y) {\n  return !ge(x, y);\n}\n\nfunction gt(x, y) {\n  if (x[\n  /* hi */\n  0] > y[\n  /* hi */\n  0]) {\n    return true;\n  } else if (x[\n  /* hi */\n  0] < y[\n  /* hi */\n  0]) {\n    return false;\n  } else {\n    return x[\n    /* lo */\n    1] > y[\n    /* lo */\n    1];\n  }\n}\n\nfunction le(x, y) {\n  return !gt(x, y);\n}\n\nfunction min(x, y) {\n  if (ge(x, y)) {\n    return y;\n  } else {\n    return x;\n  }\n}\n\nfunction max(x, y) {\n  if (gt(x, y)) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction to_float(param) {\n  return param[\n  /* hi */\n  0] * 0x100000000 + param[\n  /* lo */\n  1];\n}\n\nfunction of_float(x) {\n  if (isNaN(x) || !isFinite(x)) {\n    return zero;\n  } else if (x <= -9.22337203685477581e+18) {\n    return min_int;\n  } else if (x + 1 >= 9.22337203685477581e+18) {\n    return max_int;\n  } else if (x < 0) {\n    return neg(of_float(-x));\n  } else {\n    var hi = x / 4294967296 | 0;\n    var lo = x % 4294967296 | 0;\n    return (\n      /* record */\n      [\n      /* hi */\n      hi,\n      /* lo */\n      lo >>> 0]\n    );\n  }\n}\n\nfunction div(_self, _other) {\n  while (true) {\n    var other = _other;\n    var self = _self;\n    var self_hi = self[\n    /* hi */\n    0];\n    var exit = 0;\n    var exit$1 = 0;\n\n    if (other[\n    /* hi */\n    0] !== 0 || other[\n    /* lo */\n    1] !== 0) {\n      exit$1 = 2;\n    } else {\n      throw Caml_builtin_exceptions.division_by_zero;\n    }\n\n    if (exit$1 === 2) {\n      if (self_hi !== -2147483648) {\n        if (self_hi !== 0 || self[\n        /* lo */\n        1] !== 0) {\n          exit = 1;\n        } else {\n          return zero;\n        }\n      } else if (self[\n      /* lo */\n      1] !== 0) {\n        exit = 1;\n      } else if (eq(other, one) || eq(other, neg_one)) {\n        return self;\n      } else if (eq(other, min_int)) {\n        return one;\n      } else {\n        var other_hi = other[\n        /* hi */\n        0];\n        var half_this = asr_(self, 1);\n        var approx = lsl_(div(half_this, other), 1);\n        var exit$2 = 0;\n\n        if (approx[\n        /* hi */\n        0] !== 0 || approx[\n        /* lo */\n        1] !== 0) {\n          exit$2 = 3;\n        } else if (other_hi < 0) {\n          return one;\n        } else {\n          return neg(one);\n        }\n\n        if (exit$2 === 3) {\n          var y = mul(other, approx);\n          var rem = add(self, neg(y));\n          return add(approx, div(rem, other));\n        }\n      }\n    }\n\n    if (exit === 1) {\n      var other_hi$1 = other[\n      /* hi */\n      0];\n      var exit$3 = 0;\n\n      if (other_hi$1 !== -2147483648 || other[\n      /* lo */\n      1] !== 0) {\n        exit$3 = 2;\n      } else {\n        return zero;\n      }\n\n      if (exit$3 === 2) {\n        if (self_hi < 0) {\n          if (other_hi$1 < 0) {\n            _other = neg(other);\n            _self = neg(self);\n            continue;\n          } else {\n            return neg(div(neg(self), other));\n          }\n        } else if (other_hi$1 < 0) {\n          return neg(div(self, neg(other)));\n        } else {\n          var res = zero;\n          var rem$1 = self;\n\n          while (ge(rem$1, other)) {\n            var approx$1 = Caml_primitive.caml_float_max(1, Math.floor(to_float(rem$1) / to_float(other)));\n            var log2 = Math.ceil(Math.log(approx$1) / Math.LN2);\n            var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n            var approxRes = of_float(approx$1);\n            var approxRem = mul(approxRes, other);\n\n            while (approxRem[\n            /* hi */\n            0] < 0 || gt(approxRem, rem$1)) {\n              approx$1 -= delta;\n              approxRes = of_float(approx$1);\n              approxRem = mul(approxRes, other);\n            }\n\n            ;\n\n            if (is_zero(approxRes)) {\n              approxRes = one;\n            }\n\n            res = add(res, approxRes);\n            rem$1 = add(rem$1, neg(approxRem));\n          }\n\n          ;\n          return res;\n        }\n      }\n    }\n  }\n\n  ;\n}\n\nfunction mod_(self, other) {\n  var y = mul(div(self, other), other);\n  return add(self, neg(y));\n}\n\nfunction div_mod(self, other) {\n  var quotient = div(self, other);\n  var y = mul(quotient, other);\n  return (\n    /* tuple */\n    [quotient, add(self, neg(y))]\n  );\n}\n\nfunction compare(self, other) {\n  var v = Caml_primitive.caml_nativeint_compare(self[\n  /* hi */\n  0], other[\n  /* hi */\n  0]);\n\n  if (v === 0) {\n    return Caml_primitive.caml_nativeint_compare(self[\n    /* lo */\n    1], other[\n    /* lo */\n    1]);\n  } else {\n    return v;\n  }\n}\n\nfunction of_int32(lo) {\n  return (\n    /* record */\n    [\n    /* hi */\n    lo < 0 ? -1 : 0,\n    /* lo */\n    lo >>> 0]\n  );\n}\n\nfunction to_int32(x) {\n  return x[\n  /* lo */\n  1] | 0;\n}\n\nfunction to_hex(x) {\n  var x_lo = x[\n  /* lo */\n  1];\n  var x_hi = x[\n  /* hi */\n  0];\n\n  var aux = function (v) {\n    return (v >>> 0).toString(16);\n  };\n\n  var exit = 0;\n\n  if (x_hi !== 0 || x_lo !== 0) {\n    exit = 1;\n  } else {\n    return \"0\";\n  }\n\n  if (exit === 1) {\n    if (x_lo !== 0) {\n      if (x_hi !== 0) {\n        var lo = aux(x_lo);\n        var pad = 8 - lo.length | 0;\n\n        if (pad <= 0) {\n          return aux(x_hi) + lo;\n        } else {\n          return aux(x_hi) + (Caml_utils.repeat(pad, \"0\") + lo);\n        }\n      } else {\n        return aux(x_lo);\n      }\n    } else {\n      return aux(x_hi) + \"00000000\";\n    }\n  }\n}\n\nfunction discard_sign(x) {\n  return (\n    /* record */\n    [\n    /* hi */\n    2147483647 & x[\n    /* hi */\n    0],\n    /* lo */\n    x[\n    /* lo */\n    1]]\n  );\n}\n\nfunction float_of_bits(x) {\n  return new Float64Array(new Int32Array([x[1], x[0]]).buffer)[0];\n}\n\n;\n\nfunction bits_of_float(x) {\n  var buf = new Int32Array(new Float64Array([x]).buffer);\n  return (\n    /* record */\n    [\n    /* hi */\n    buf[1],\n    /* lo */\n    buf[0] >>> 0]\n  );\n}\n\nfunction get64(s, i) {\n  var hi = s.charCodeAt(i + 4 | 0) << 32 | s.charCodeAt(i + 5 | 0) << 40 | s.charCodeAt(i + 6 | 0) << 48 | s.charCodeAt(i + 7 | 0) << 56;\n  var lo = s.charCodeAt(i) | s.charCodeAt(i + 1 | 0) << 8 | s.charCodeAt(i + 2 | 0) << 16 | s.charCodeAt(i + 3 | 0) << 24;\n  return (\n    /* record */\n    [\n    /* hi */\n    hi,\n    /* lo */\n    lo >>> 0]\n  );\n}\n\nexport { min_int, max_int, one, zero, not, of_int32, to_int32, add, neg, sub, lsl_, lsr_, asr_, is_zero, mul, xor, or_, and_, swap, ge, eq, neq, lt, gt, le, equal_null, equal_undefined, equal_nullable, min, max, to_float, of_float, div, mod_, compare, float_of_bits, bits_of_float, get64, div_mod, to_hex, discard_sign };\n/* Caml_int32 Not a pure module */","map":{"version":3,"sources":["/Users/bg/benzguo/memopub/node_modules/bs-platform/lib/es6/caml_int64.js"],"names":["Caml_int32","Caml_utils","Caml_primitive","Caml_builtin_exceptions","min_int","max_int","one","zero","neg_one","neg_signed","x","add","param","param$1","other_low_","this_low_","lo","overflow","hi","not","eq","y","equal_null","equal_undefined","undefined","equal_nullable","neg","sub","lsl_","numBits","lsr_","offset","hi$1","lo$1","asr_","is_zero","mul","_this","_other","other","$$this","exit","this_hi","exit$1","exit$2","exit$3","other_hi","exit$4","other_lo","a48","a32","a16","a00","b48","b32","b16","b00","c48","c32","c16","c00","lo$2","swap","caml_int32_bswap","xor","or_","and_","ge","neq","lt","gt","le","min","max","to_float","of_float","isNaN","isFinite","div","_self","self","self_hi","division_by_zero","half_this","approx","rem","other_hi$1","res","rem$1","approx$1","caml_float_max","Math","floor","log2","ceil","log","LN2","delta","pow","approxRes","approxRem","mod_","div_mod","quotient","compare","v","caml_nativeint_compare","of_int32","to_int32","to_hex","x_lo","x_hi","aux","toString","pad","length","repeat","discard_sign","float_of_bits","Float64Array","Int32Array","buffer","bits_of_float","buf","get64","s","i","charCodeAt"],"mappings":"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","sourcesContent":["\n\nimport * as Caml_int32 from \"./caml_int32.js\";\nimport * as Caml_utils from \"./caml_utils.js\";\nimport * as Caml_primitive from \"./caml_primitive.js\";\nimport * as Caml_builtin_exceptions from \"./caml_builtin_exceptions.js\";\n\nvar min_int = /* record */[\n  /* hi */-2147483648,\n  /* lo */0\n];\n\nvar max_int = /* record */[\n  /* hi */2147483647,\n  /* lo */1\n];\n\nvar one = /* record */[\n  /* hi */0,\n  /* lo */1\n];\n\nvar zero = /* record */[\n  /* hi */0,\n  /* lo */0\n];\n\nvar neg_one = /* record */[\n  /* hi */-1,\n  /* lo */4294967295\n];\n\nfunction neg_signed(x) {\n  return (x & 2147483648) !== 0;\n}\n\nfunction add(param, param$1) {\n  var other_low_ = param$1[/* lo */1];\n  var this_low_ = param[/* lo */1];\n  var lo = this_low_ + other_low_ & 4294967295;\n  var overflow = neg_signed(this_low_) && (neg_signed(other_low_) || !neg_signed(lo)) || neg_signed(other_low_) && !neg_signed(lo) ? 1 : 0;\n  var hi = param[/* hi */0] + param$1[/* hi */0] + overflow & 4294967295;\n  return /* record */[\n          /* hi */hi,\n          /* lo */(lo >>> 0)\n        ];\n}\n\nfunction not(param) {\n  var hi = param[/* hi */0] ^ -1;\n  var lo = param[/* lo */1] ^ -1;\n  return /* record */[\n          /* hi */hi,\n          /* lo */(lo >>> 0)\n        ];\n}\n\nfunction eq(x, y) {\n  if (x[/* hi */0] === y[/* hi */0]) {\n    return x[/* lo */1] === y[/* lo */1];\n  } else {\n    return false;\n  }\n}\n\nfunction equal_null(x, y) {\n  if (y !== null) {\n    return eq(x, y);\n  } else {\n    return false;\n  }\n}\n\nfunction equal_undefined(x, y) {\n  if (y !== undefined) {\n    return eq(x, y);\n  } else {\n    return false;\n  }\n}\n\nfunction equal_nullable(x, y) {\n  if (y == null) {\n    return false;\n  } else {\n    return eq(x, y);\n  }\n}\n\nfunction neg(x) {\n  if (eq(x, min_int)) {\n    return min_int;\n  } else {\n    return add(not(x), one);\n  }\n}\n\nfunction sub(x, y) {\n  return add(x, neg(y));\n}\n\nfunction lsl_(x, numBits) {\n  if (numBits === 0) {\n    return x;\n  } else {\n    var lo = x[/* lo */1];\n    if (numBits >= 32) {\n      return /* record */[\n              /* hi */(lo << (numBits - 32 | 0)),\n              /* lo */0\n            ];\n    } else {\n      var hi = (lo >>> (32 - numBits | 0)) | (x[/* hi */0] << numBits);\n      return /* record */[\n              /* hi */hi,\n              /* lo */((lo << numBits) >>> 0)\n            ];\n    }\n  }\n}\n\nfunction lsr_(x, numBits) {\n  if (numBits === 0) {\n    return x;\n  } else {\n    var hi = x[/* hi */0];\n    var offset = numBits - 32 | 0;\n    if (offset === 0) {\n      return /* record */[\n              /* hi */0,\n              /* lo */(hi >>> 0)\n            ];\n    } else if (offset > 0) {\n      var lo = (hi >>> offset);\n      return /* record */[\n              /* hi */0,\n              /* lo */(lo >>> 0)\n            ];\n    } else {\n      var hi$1 = (hi >>> numBits);\n      var lo$1 = (hi << (-offset | 0)) | (x[/* lo */1] >>> numBits);\n      return /* record */[\n              /* hi */hi$1,\n              /* lo */(lo$1 >>> 0)\n            ];\n    }\n  }\n}\n\nfunction asr_(x, numBits) {\n  if (numBits === 0) {\n    return x;\n  } else {\n    var hi = x[/* hi */0];\n    if (numBits < 32) {\n      var hi$1 = (hi >> numBits);\n      var lo = (hi << (32 - numBits | 0)) | (x[/* lo */1] >>> numBits);\n      return /* record */[\n              /* hi */hi$1,\n              /* lo */(lo >>> 0)\n            ];\n    } else {\n      var lo$1 = (hi >> (numBits - 32 | 0));\n      return /* record */[\n              /* hi */hi >= 0 ? 0 : -1,\n              /* lo */(lo$1 >>> 0)\n            ];\n    }\n  }\n}\n\nfunction is_zero(param) {\n  if (param[/* hi */0] !== 0 || param[/* lo */1] !== 0) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction mul(_this, _other) {\n  while(true) {\n    var other = _other;\n    var $$this = _this;\n    var exit = 0;\n    var lo;\n    var this_hi = $$this[/* hi */0];\n    var exit$1 = 0;\n    var exit$2 = 0;\n    var exit$3 = 0;\n    if (this_hi !== 0 || $$this[/* lo */1] !== 0) {\n      exit$3 = 4;\n    } else {\n      return zero;\n    }\n    if (exit$3 === 4) {\n      if (other[/* hi */0] !== 0 || other[/* lo */1] !== 0) {\n        exit$2 = 3;\n      } else {\n        return zero;\n      }\n    }\n    if (exit$2 === 3) {\n      if (this_hi !== -2147483648 || $$this[/* lo */1] !== 0) {\n        exit$1 = 2;\n      } else {\n        lo = other[/* lo */1];\n        exit = 1;\n      }\n    }\n    if (exit$1 === 2) {\n      var other_hi = other[/* hi */0];\n      var lo$1 = $$this[/* lo */1];\n      var exit$4 = 0;\n      if (other_hi !== -2147483648 || other[/* lo */1] !== 0) {\n        exit$4 = 3;\n      } else {\n        lo = lo$1;\n        exit = 1;\n      }\n      if (exit$4 === 3) {\n        var other_lo = other[/* lo */1];\n        if (this_hi < 0) {\n          if (other_hi < 0) {\n            _other = neg(other);\n            _this = neg($$this);\n            continue ;\n          } else {\n            return neg(mul(neg($$this), other));\n          }\n        } else if (other_hi < 0) {\n          return neg(mul($$this, neg(other)));\n        } else {\n          var a48 = (this_hi >>> 16);\n          var a32 = this_hi & 65535;\n          var a16 = (lo$1 >>> 16);\n          var a00 = lo$1 & 65535;\n          var b48 = (other_hi >>> 16);\n          var b32 = other_hi & 65535;\n          var b16 = (other_lo >>> 16);\n          var b00 = other_lo & 65535;\n          var c48 = 0;\n          var c32 = 0;\n          var c16 = 0;\n          var c00 = a00 * b00;\n          c16 = (c00 >>> 16) + a16 * b00;\n          c32 = (c16 >>> 16);\n          c16 = (c16 & 65535) + a00 * b16;\n          c32 = c32 + (c16 >>> 16) + a32 * b00;\n          c48 = (c32 >>> 16);\n          c32 = (c32 & 65535) + a16 * b16;\n          c48 += (c32 >>> 16);\n          c32 = (c32 & 65535) + a00 * b32;\n          c48 += (c32 >>> 16);\n          c32 = c32 & 65535;\n          c48 = c48 + (a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48) & 65535;\n          var hi = c32 | (c48 << 16);\n          var lo$2 = c00 & 65535 | ((c16 & 65535) << 16);\n          return /* record */[\n                  /* hi */hi,\n                  /* lo */(lo$2 >>> 0)\n                ];\n        }\n      }\n      \n    }\n    if (exit === 1) {\n      if ((lo & 1) === 0) {\n        return zero;\n      } else {\n        return min_int;\n      }\n    }\n    \n  };\n}\n\nfunction swap(param) {\n  var hi = Caml_int32.caml_int32_bswap(param[/* lo */1]);\n  var lo = Caml_int32.caml_int32_bswap(param[/* hi */0]);\n  return /* record */[\n          /* hi */hi,\n          /* lo */(lo >>> 0)\n        ];\n}\n\nfunction xor(param, param$1) {\n  return /* record */[\n          /* hi */param[/* hi */0] ^ param$1[/* hi */0],\n          /* lo */((param[/* lo */1] ^ param$1[/* lo */1]) >>> 0)\n        ];\n}\n\nfunction or_(param, param$1) {\n  return /* record */[\n          /* hi */param[/* hi */0] | param$1[/* hi */0],\n          /* lo */((param[/* lo */1] | param$1[/* lo */1]) >>> 0)\n        ];\n}\n\nfunction and_(param, param$1) {\n  return /* record */[\n          /* hi */param[/* hi */0] & param$1[/* hi */0],\n          /* lo */((param[/* lo */1] & param$1[/* lo */1]) >>> 0)\n        ];\n}\n\nfunction ge(param, param$1) {\n  var other_hi = param$1[/* hi */0];\n  var hi = param[/* hi */0];\n  if (hi > other_hi) {\n    return true;\n  } else if (hi < other_hi) {\n    return false;\n  } else {\n    return param[/* lo */1] >= param$1[/* lo */1];\n  }\n}\n\nfunction neq(x, y) {\n  return !eq(x, y);\n}\n\nfunction lt(x, y) {\n  return !ge(x, y);\n}\n\nfunction gt(x, y) {\n  if (x[/* hi */0] > y[/* hi */0]) {\n    return true;\n  } else if (x[/* hi */0] < y[/* hi */0]) {\n    return false;\n  } else {\n    return x[/* lo */1] > y[/* lo */1];\n  }\n}\n\nfunction le(x, y) {\n  return !gt(x, y);\n}\n\nfunction min(x, y) {\n  if (ge(x, y)) {\n    return y;\n  } else {\n    return x;\n  }\n}\n\nfunction max(x, y) {\n  if (gt(x, y)) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction to_float(param) {\n  return param[/* hi */0] * (0x100000000) + param[/* lo */1];\n}\n\nfunction of_float(x) {\n  if (isNaN(x) || !isFinite(x)) {\n    return zero;\n  } else if (x <= -9.22337203685477581e+18) {\n    return min_int;\n  } else if (x + 1 >= 9.22337203685477581e+18) {\n    return max_int;\n  } else if (x < 0) {\n    return neg(of_float(-x));\n  } else {\n    var hi = x / 4294967296 | 0;\n    var lo = x % 4294967296 | 0;\n    return /* record */[\n            /* hi */hi,\n            /* lo */(lo >>> 0)\n          ];\n  }\n}\n\nfunction div(_self, _other) {\n  while(true) {\n    var other = _other;\n    var self = _self;\n    var self_hi = self[/* hi */0];\n    var exit = 0;\n    var exit$1 = 0;\n    if (other[/* hi */0] !== 0 || other[/* lo */1] !== 0) {\n      exit$1 = 2;\n    } else {\n      throw Caml_builtin_exceptions.division_by_zero;\n    }\n    if (exit$1 === 2) {\n      if (self_hi !== -2147483648) {\n        if (self_hi !== 0 || self[/* lo */1] !== 0) {\n          exit = 1;\n        } else {\n          return zero;\n        }\n      } else if (self[/* lo */1] !== 0) {\n        exit = 1;\n      } else if (eq(other, one) || eq(other, neg_one)) {\n        return self;\n      } else if (eq(other, min_int)) {\n        return one;\n      } else {\n        var other_hi = other[/* hi */0];\n        var half_this = asr_(self, 1);\n        var approx = lsl_(div(half_this, other), 1);\n        var exit$2 = 0;\n        if (approx[/* hi */0] !== 0 || approx[/* lo */1] !== 0) {\n          exit$2 = 3;\n        } else if (other_hi < 0) {\n          return one;\n        } else {\n          return neg(one);\n        }\n        if (exit$2 === 3) {\n          var y = mul(other, approx);\n          var rem = add(self, neg(y));\n          return add(approx, div(rem, other));\n        }\n        \n      }\n    }\n    if (exit === 1) {\n      var other_hi$1 = other[/* hi */0];\n      var exit$3 = 0;\n      if (other_hi$1 !== -2147483648 || other[/* lo */1] !== 0) {\n        exit$3 = 2;\n      } else {\n        return zero;\n      }\n      if (exit$3 === 2) {\n        if (self_hi < 0) {\n          if (other_hi$1 < 0) {\n            _other = neg(other);\n            _self = neg(self);\n            continue ;\n          } else {\n            return neg(div(neg(self), other));\n          }\n        } else if (other_hi$1 < 0) {\n          return neg(div(self, neg(other)));\n        } else {\n          var res = zero;\n          var rem$1 = self;\n          while(ge(rem$1, other)) {\n            var approx$1 = Caml_primitive.caml_float_max(1, Math.floor(to_float(rem$1) / to_float(other)));\n            var log2 = Math.ceil(Math.log(approx$1) / Math.LN2);\n            var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n            var approxRes = of_float(approx$1);\n            var approxRem = mul(approxRes, other);\n            while(approxRem[/* hi */0] < 0 || gt(approxRem, rem$1)) {\n              approx$1 -= delta;\n              approxRes = of_float(approx$1);\n              approxRem = mul(approxRes, other);\n            };\n            if (is_zero(approxRes)) {\n              approxRes = one;\n            }\n            res = add(res, approxRes);\n            rem$1 = add(rem$1, neg(approxRem));\n          };\n          return res;\n        }\n      }\n      \n    }\n    \n  };\n}\n\nfunction mod_(self, other) {\n  var y = mul(div(self, other), other);\n  return add(self, neg(y));\n}\n\nfunction div_mod(self, other) {\n  var quotient = div(self, other);\n  var y = mul(quotient, other);\n  return /* tuple */[\n          quotient,\n          add(self, neg(y))\n        ];\n}\n\nfunction compare(self, other) {\n  var v = Caml_primitive.caml_nativeint_compare(self[/* hi */0], other[/* hi */0]);\n  if (v === 0) {\n    return Caml_primitive.caml_nativeint_compare(self[/* lo */1], other[/* lo */1]);\n  } else {\n    return v;\n  }\n}\n\nfunction of_int32(lo) {\n  return /* record */[\n          /* hi */lo < 0 ? -1 : 0,\n          /* lo */(lo >>> 0)\n        ];\n}\n\nfunction to_int32(x) {\n  return x[/* lo */1] | 0;\n}\n\nfunction to_hex(x) {\n  var x_lo = x[/* lo */1];\n  var x_hi = x[/* hi */0];\n  var aux = function (v) {\n    return (v >>> 0).toString(16);\n  };\n  var exit = 0;\n  if (x_hi !== 0 || x_lo !== 0) {\n    exit = 1;\n  } else {\n    return \"0\";\n  }\n  if (exit === 1) {\n    if (x_lo !== 0) {\n      if (x_hi !== 0) {\n        var lo = aux(x_lo);\n        var pad = 8 - lo.length | 0;\n        if (pad <= 0) {\n          return aux(x_hi) + lo;\n        } else {\n          return aux(x_hi) + (Caml_utils.repeat(pad, \"0\") + lo);\n        }\n      } else {\n        return aux(x_lo);\n      }\n    } else {\n      return aux(x_hi) + \"00000000\";\n    }\n  }\n  \n}\n\nfunction discard_sign(x) {\n  return /* record */[\n          /* hi */2147483647 & x[/* hi */0],\n          /* lo */x[/* lo */1]\n        ];\n}\n\nfunction float_of_bits (x){ \n  return new Float64Array(new Int32Array([x[1],x[0]]).buffer)[0]\n};\n\nfunction bits_of_float(x) {\n  var buf = (new Int32Array(new Float64Array([x]).buffer));\n  return /* record */[\n          /* hi */buf[1],\n          /* lo */(buf[0] >>> 0)\n        ];\n}\n\nfunction get64(s, i) {\n  var hi = (s.charCodeAt(i + 4 | 0) << 32) | (s.charCodeAt(i + 5 | 0) << 40) | (s.charCodeAt(i + 6 | 0) << 48) | (s.charCodeAt(i + 7 | 0) << 56);\n  var lo = s.charCodeAt(i) | (s.charCodeAt(i + 1 | 0) << 8) | (s.charCodeAt(i + 2 | 0) << 16) | (s.charCodeAt(i + 3 | 0) << 24);\n  return /* record */[\n          /* hi */hi,\n          /* lo */(lo >>> 0)\n        ];\n}\n\nexport {\n  min_int ,\n  max_int ,\n  one ,\n  zero ,\n  not ,\n  of_int32 ,\n  to_int32 ,\n  add ,\n  neg ,\n  sub ,\n  lsl_ ,\n  lsr_ ,\n  asr_ ,\n  is_zero ,\n  mul ,\n  xor ,\n  or_ ,\n  and_ ,\n  swap ,\n  ge ,\n  eq ,\n  neq ,\n  lt ,\n  gt ,\n  le ,\n  equal_null ,\n  equal_undefined ,\n  equal_nullable ,\n  min ,\n  max ,\n  to_float ,\n  of_float ,\n  div ,\n  mod_ ,\n  compare ,\n  float_of_bits ,\n  bits_of_float ,\n  get64 ,\n  div_mod ,\n  to_hex ,\n  discard_sign ,\n  \n}\n/* Caml_int32 Not a pure module */\n"]},"metadata":{},"sourceType":"module"}